- name: 'Configure kubeconfig Backup Cron Job  | configure-kubeconfig download-cronjob.yml'
  hosts: localhost
  become: yes
  vars:
    ansible_python_interpreter: /usr/bin/python3
  vars_files:
    - 'vars/vault.yml'
    - 'vars/global.yml'
    - 'vars/infra.yml'
  vars:
    module: "configure-kubeconfig download-cron"
    ansible_name_module: "Configure kubeconfig Backup Cron Job | {{ module }}"

  pre_tasks:
    - name: '{{ ansible_name_module }} | assert | The AWS access key is defined '
      ansible.builtin.assert:
        that:
          - aws_access_key is defined
          - aws_access_key != ''
        msg: "The AWS cloud credentials access key is required to run this playbook."
      when:
        - not aws_access_key is defined or aws_access_key == ''

    - name: '{{ ansible_name_module }} | assert | The AWS access secret is defined '
      ansible.builtin.assert:
        that:
          - aws_access_secret is defined
          - aws_access_secret != ''
        msg: "The AWS cloud credentials access secret is required to run this playbook."
      when:
        - not aws_access_secret is defined or aws_access_secret == ''

    - name: Install required pip library
      pip:
        name: openshift
        state: present

    - name: Ensure Proper Python dependency is installed for Openshift
      python_requirements_facts:
        dependencies:
          - openshift
          - requests

    - name: Authenticate with the API
      command: >
        {{ openshift_cli }} login \
          --token {{ ocp_cluster_token }} \
          --insecure-skip-tls-verify=true {{ ocp_cluster_console_url }}:{{ ocp_cluster_console_port | d('6443', true) }}
      when:
        - ocp_cluster_token is defined and ocp_cluster_token != ""
      register: login_out

    - name: Authenticate with the API
      command: >
        {{ openshift_cli }} login \
          -u {{ ocp_cluster_user }} \
          -p {{ ocp_cluster_user_password }} \
          --insecure-skip-tls-verify=true {{ ocp_cluster_console_url }}:{{ ocp_cluster_console_port | d('6443', true) }}
      when:
        - not ocp_cluster_token is defined or ocp_cluster_token == ""
      register: login_out

  tasks:
    - name: '{{ ansible_name_module }} | Create kubeconfig Backup Namespace'
      block:
        ##### Adding this to bypass restrictions on creating project with names starting with openshift  #####
        - name: '{{ ansible_name_module }} |  Create kubeconfig download Namespace'
          command: >
            {{ openshift_cli }} create namespace '{{ kubeconfig_job_namespace }}'
          failed_when: "kubeconfig_ns_created.rc >=1 and not ' already exists' in kubeconfig_ns_created.stderr"
          when:
            - "'openshift' in kubeconfig_job_namespace"
          register: kubeconfig_ns_created

        - name: '{{ ansible_name_module }} |  Create kubeconfig download Namespace'
          command: >
            {{ openshift_cli }} new-project '{{ kubeconfig_job_namespace }}' \
              --display-name='{{ kubeconfig_job_namespace_description }}' \
              --description='{{ kubeconfig_job_namespace_description }}'
          failed_when: "kubeconfig_ns_created.rc >=1 and not ' already exists' in kubeconfig_ns_created.stderr"
          when:
            - "not 'openshift' in kubeconfig_job_namespace"
          register: kubeconfig_ns_created

    - name: '{{ ansible_name_module }} | Create k8 secret for AWS access credentials'
      block:
        - name: '{{ ansible_name_module }} |  Create from AWS Access key'
          command: >
            {{ openshift_cli }} create \
             secret generic {{ aws_account_creds_secret }} \
             --from-literal=aws_access_key={{ aws_access_key }} \
             --from-literal=aws_access_secret={{ aws_key_secret }} \
             -n '{{ kubeconfig_job_namespace }}'
          failed_when: "secret_created.rc >=1 and not ' already exists' in secret_created.stderr"
          register: secret_created

    - name:  '{{ ansible_name_module }} | create service account'
      ansible.builtin.command: >
        {{ openshift_cli }} create serviceaccount {{ kubeconfig_service_account }} -n {{ kubeconfig_job_namespace }}
      failed_when: "sa_created.rc > 0 and not ' already exists' in sa_created.stderr"
      register: sa_created

       ### You need to have cluster admin role to run this task
    - name: Grant SCC Privilege to the kubeconfig Backup service account
      when:
         - add_privileged_scc_to_kubeconfig_sa is defined
         - add_privileged_scc_to_kubeconfig_sa | default('false') | bool
      block:
      - name: Grant Privileged SCC access
        command: >
          {{ openshift_cli }} adm policy \
            add-scc-to-user {{ scc_name }} \
            'system:serviceaccount:{{ kubeconfig_job_namespace }}:{{ item }}'
        failed_when:
          - privileged_access_granted.rc >= 1
          - not 'AlreadyExists' in privileged_access_granted.stderr
        with_items:
          - "{{ kubeconfig_service_account }}"
        when:
          - add_privileged_scc_to_kubeconfig_sa | bool
          - item != ""
        register: privileged_access_granted
        tags: privileged

    - name: '{{ ansible_name_module }} | Configure kubeconfig download '
      block:
        - name: '{{ ansible_name_module }} | Retrieve Infrastructure ID'
          ansible.builtin.command: >
            {{ openshift_cli }} get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster
          register: cluster_id

        - name: '{{ ansible_name_module }} | Retrieve Infrastructure Region'
          ansible.builtin.command: >
            {{ openshift_cli }} get -o jsonpath='{.status.platformStatus.aws.region}{"\n"}' infrastructure cluster
          when:
            - not aws_region is defined or aws_region == '' 
          register: cluster_aws_region

        - name: '{{ ansible_name_module }} | Set Bucket region'
          ansible.builtin.set_fact:
            aws_region: "{{ cluster_aws_region.stdout }}"
          when:
            - cluster_aws_region is defined
            - cluster_aws_region.rc is defined
            - cluster_aws_region.rc == 0 
            - cluster_aws_region.stdout is defined
            - cluster_aws_region.stdout != ''

        - name: '{{ ansible_name_module }} | Set AWS CA bundle file path within the container'
          ansible.builtin.set_fact:
            aws_ca_bundle_path: "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem"
          when:
            - not aws_ca_bundle_path is defined or aws_ca_bundle_path == ''

        - name: '{{ ansible_name_module }} | Set Bucket name'
          ansible.builtin.set_fact:
            kubeconfig_aws_bucket: "{{ cluster_id.stdout }}-kubeconfig-backup"
          when:
            - not kubeconfig_aws_bucket is defined or kubeconfig_aws_bucket == ''

        - name: '{{ ansible_name_module }} | Set kubeconfig_cron_jon_schedule_expression'
          ansible.builtin.set_fact:
            kubeconfig_cron_jon_schedule_expression: '{{ ansible_date_time.minute | int +2 }} {{ ansible_date_time.hour }} * * 5' 
          when:
            - not kubeconfig_cron_jon_schedule_expression is defined or kubeconfig_cron_jon_schedule_expression == ''

        - name: '{{ ansible_name_module }} | template | Render Kubeconfig backup cronjob'
          ansible.builtin.template:
            src: "templates/kubeconfig-download-cronjob.yaml.j2"
            dest: "{{ staging_dir | d('/tmp', true) }}/{{ cluster_id.stdout }}-{{ kubeconfig_service_name }}-cronjob.yaml"
            force: yes
          vars:
          register: kubeconfig_cronjob_copied

        - name: '{{ ansible_name_module }} | ansible.builtin.command:{{ openshift_cli }} apply | create kubeconfig backup cron job'
          ansible.builtin.command: >
            {{ openshift_cli }} apply -f {{ kubeconfig_cronjob_copied.dest }}
          when:
            - kubeconfig_cronjob_copied is defined
            - kubeconfig_cronjob_copied.dest is defined
            - kubeconfig_cronjob_copied.state is defined
            - "'file' in kubeconfig_cronjob_copied.state"
          register: kubeconfigcron_created
